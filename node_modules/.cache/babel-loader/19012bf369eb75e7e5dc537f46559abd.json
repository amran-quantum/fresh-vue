{"remainingRequest":"/home/amran/test-projects/vue/vue-record/node_modules/babel-loader/lib/index.js!/home/amran/test-projects/vue/vue-record/node_modules/eslint-loader/index.js??ref--13-0!/home/amran/test-projects/vue/vue-record/src/components/RecorderMixin.js","dependencies":[{"path":"/home/amran/test-projects/vue/vue-record/src/components/RecorderMixin.js","mtime":1623894433000},{"path":"/home/amran/test-projects/vue/vue-record/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/amran/test-projects/vue/vue-record/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/amran/test-projects/vue/vue-record/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/amran/test-projects/vue/vue-record/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nexport default {\n  data: function data() {\n    return {\n      isSupported: false,\n      hasPermission: false,\n      isRecording: false,\n      isPaused: false,\n      chunks: []\n    };\n  },\n  methods: {\n    start: function () {\n      var _start = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.isRecording) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.prev = 2;\n                _context.next = 5;\n                return this.getStream();\n\n              case 5:\n                this.$_stream = _context.sent;\n                this.prepareRecorder();\n                this.$_mediaRecorder.start();\n                _context.next = 14;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](2);\n                this.$emit('error', _context.t0); // eslint-disable-next-line\n\n                console.error(_context.t0);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 10]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }(),\n    stop: function stop() {\n      if (!this.isRecording) return;\n      this.$_mediaRecorder.stop();\n      this.$_stream.getTracks().forEach(function (t) {\n        return t.stop();\n      });\n    },\n    pause: function pause() {\n      if (!this.isRecording) return;\n      this.$_mediaRecorder.pause();\n    },\n    resume: function resume() {\n      if (!this.isPaused) return;\n      this.$_mediaRecorder.resume();\n    },\n\n    /**\r\n     * Get the input stream based on constraints and emit the stream event\r\n     * to the parent component so he can use it for processing or show a preview\r\n     */\n    getStream: function () {\n      var _getStream = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2() {\n        var stream;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return navigator.mediaDevices.getUserMedia(this.constraints);\n\n              case 2:\n                stream = _context2.sent;\n                this.$_stream = stream;\n                this.$emit('stream', stream);\n                return _context2.abrupt(\"return\", stream);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getStream() {\n        return _getStream.apply(this, arguments);\n      }\n\n      return getStream;\n    }(),\n\n    /**\r\n     * Create a new media recorder with the user media stream\r\n     * and set some event listeners to update component data\r\n     * and emit events to the parent component\r\n     */\n    prepareRecorder: function prepareRecorder() {\n      var _this = this;\n\n      if (!this.$_stream) {\n        return;\n      }\n\n      this.$_mediaRecorder = new MediaRecorder(this.$_stream, {\n        mimeType: this.mimeType\n      });\n      this.$_mediaRecorder.ignoreMutedMedia = true;\n      this.$_mediaRecorder.addEventListener('start', function () {\n        _this.isRecording = true;\n        _this.isPaused = false;\n\n        _this.$emit('start');\n      });\n      this.$_mediaRecorder.addEventListener('resume', function () {\n        _this.isRecording = true;\n        _this.isPaused = false;\n\n        _this.$emit('resume');\n      });\n      this.$_mediaRecorder.addEventListener('pause', function () {\n        _this.isPaused = true;\n\n        _this.$emit('pause');\n      }); // Collect the available data into chunks\n\n      this.$_mediaRecorder.addEventListener('dataavailable', function (e) {\n        if (e.data && e.data.size > 0) {\n          _this.chunks.push(e.data);\n        }\n      }, true); // On recording stop get the data and emit the result\n      // than clear all the recording chunks\n\n      this.$_mediaRecorder.addEventListener('stop', function () {\n        _this.$emit('stop'); // type: \"video/x-matroska;codecs=avc1,opus\"\n\n\n        var blobData = new Blob(_this.chunks, {\n          type: \"video/mp4\"\n        });\n\n        if (blobData.size > 0) {\n          _this.$emit('result', blobData);\n        }\n\n        _this.chunks = [];\n        _this.isPaused = false;\n        _this.isRecording = false;\n      }, true);\n    }\n  },\n  mounted: function mounted() {\n    if (!navigator.mediaDevices && !navigator.mediaDevices.getUserMedia) {\n      // eslint-disable-next-line\n      console.warn('Media Devices are not supported from your browser.');\n      return;\n    } // video recorder on Safari is not currently supported\n    // TODO: we could use https://github.com/CameraKit/webm-media-recorder\n\n\n    if (!window.MediaRecorder && this.constraints.video) {\n      // eslint-disable-next-line\n      console.warn('MediaRecorder for video is not supported from your browser.');\n      return;\n    }\n\n    this.isSupported = true;\n  }\n};",{"version":3,"sources":["/home/amran/test-projects/vue/vue-record/src/components/RecorderMixin.js"],"names":["data","isSupported","hasPermission","isRecording","isPaused","chunks","methods","start","getStream","$_stream","prepareRecorder","$_mediaRecorder","$emit","console","error","stop","getTracks","forEach","t","pause","resume","navigator","mediaDevices","getUserMedia","constraints","stream","MediaRecorder","mimeType","ignoreMutedMedia","addEventListener","e","size","push","blobData","Blob","type","mounted","warn","window","video"],"mappings":"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","sourcesContent":["export default {\r\n  data() {\r\n    return {\r\n      isSupported: false,\r\n      hasPermission: false,\r\n      isRecording: false,\r\n      isPaused: false,\r\n      chunks: []\r\n    }\r\n  },\r\n  methods: {\r\n    async start() {\r\n      if (this.isRecording) {\r\n        return\r\n      }\r\n\r\n      try {\r\n        this.$_stream = await this.getStream()\r\n        this.prepareRecorder()\r\n        this.$_mediaRecorder.start()\r\n      } catch (e) {\r\n        this.$emit('error', e)\r\n        // eslint-disable-next-line\r\n        console.error(e);\r\n      }\r\n    },\r\n    stop() {\r\n      if (!this.isRecording) return\r\n      this.$_mediaRecorder.stop()\r\n      this.$_stream.getTracks().forEach(t => t.stop())\r\n    },\r\n    pause() {\r\n      if (!this.isRecording) return\r\n      this.$_mediaRecorder.pause()\r\n    },\r\n    resume() {\r\n      if (!this.isPaused) return\r\n      this.$_mediaRecorder.resume()\r\n    },\r\n\r\n    /**\r\n     * Get the input stream based on constraints and emit the stream event\r\n     * to the parent component so he can use it for processing or show a preview\r\n     */\r\n    async getStream() {\r\n      const stream = await navigator.mediaDevices.getUserMedia(this.constraints)\r\n      this.$_stream = stream\r\n      this.$emit('stream', stream)\r\n      return stream\r\n    },\r\n\r\n    /**\r\n     * Create a new media recorder with the user media stream\r\n     * and set some event listeners to update component data\r\n     * and emit events to the parent component\r\n     */\r\n    prepareRecorder() {\r\n      if (!this.$_stream) {\r\n        return\r\n      }\r\n\r\n      this.$_mediaRecorder = new MediaRecorder(this.$_stream, {\r\n        mimeType: this.mimeType\r\n      })\r\n\r\n      this.$_mediaRecorder.ignoreMutedMedia = true\r\n\r\n      this.$_mediaRecorder.addEventListener('start', () => {\r\n        this.isRecording = true\r\n        this.isPaused = false\r\n        this.$emit('start')\r\n      })\r\n\r\n      this.$_mediaRecorder.addEventListener('resume', () => {\r\n        this.isRecording = true\r\n        this.isPaused = false\r\n        this.$emit('resume')\r\n      })\r\n\r\n      this.$_mediaRecorder.addEventListener('pause', () => {\r\n        this.isPaused = true\r\n        this.$emit('pause')\r\n      })\r\n\r\n      // Collect the available data into chunks\r\n      this.$_mediaRecorder.addEventListener('dataavailable', (e) => {\r\n        if (e.data && e.data.size > 0) {\r\n          this.chunks.push(e.data)\r\n        }\r\n      }, true)\r\n\r\n      // On recording stop get the data and emit the result\r\n      // than clear all the recording chunks\r\n      this.$_mediaRecorder.addEventListener('stop', () => {\r\n        this.$emit('stop')\r\n        // type: \"video/x-matroska;codecs=avc1,opus\"\r\n        const blobData = new Blob(this.chunks, {type: \"video/mp4\"})\r\n        if (blobData.size > 0) {\r\n          this.$emit('result', blobData)\r\n        }\r\n        this.chunks = []\r\n        this.isPaused = false\r\n        this.isRecording = false\r\n      }, true)\r\n    }\r\n  },\r\n  mounted() {\r\n    if (!navigator.mediaDevices && !navigator.mediaDevices.getUserMedia) {\r\n      // eslint-disable-next-line\r\n      console.warn('Media Devices are not supported from your browser.')\r\n      return\r\n    }\r\n\r\n    // video recorder on Safari is not currently supported\r\n    // TODO: we could use https://github.com/CameraKit/webm-media-recorder\r\n    if (!window.MediaRecorder && this.constraints.video) {\r\n      // eslint-disable-next-line\r\n      console.warn('MediaRecorder for video is not supported from your browser.')\r\n      return\r\n    }\r\n\r\n    this.isSupported = true\r\n  }\r\n}\r\n"]}]}