{"remainingRequest":"/home/amran/test-projects/vue/vue-record/node_modules/babel-loader/lib/index.js!/home/amran/test-projects/vue/vue-record/node_modules/eslint-loader/index.js??ref--13-0!/home/amran/test-projects/vue/vue-record/src/components/SafariRecorderMixin.js","dependencies":[{"path":"/home/amran/test-projects/vue/vue-record/src/components/SafariRecorderMixin.js","mtime":1623930088000},{"path":"/home/amran/test-projects/vue/vue-record/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/amran/test-projects/vue/vue-record/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/amran/test-projects/vue/vue-record/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/home/amran/test-projects/vue/vue-record/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport { loadScripts } from \"./loadScripts\";\nimport StartAudioContext from \"startaudiocontext\";\nimport Tone from \"tone\"; // https://github.com/Tonejs/Tone.js/issues/341\n// https://github.com/tambien/StartAudioContext\n// StartAudioContext(Tone.context);\n\nexport default {\n  methods: {\n    start: function () {\n      var _start = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.isRecording) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.prev = 2;\n                _context.next = 5;\n                return this.getStream();\n\n              case 5:\n                this.$_stream = _context.sent;\n                _context.next = 8;\n                return this.prepareRecorder();\n\n              case 8:\n                this.$_mediaRecorder.start();\n                Tone.Transport.start();\n                _context.next = 16;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](2);\n                this.$emit(\"error\", _context.t0); // eslint-disable-next-line\n\n                console.error(_context.t0);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 12]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }(),\n    stop: function stop() {\n      if (!this.isRecording) return;\n      this.$_mediaRecorder.stop();\n      this.$_stream.getTracks().forEach(function (t) {\n        return t.stop();\n      });\n      this.$_mic.close();\n      Tone.Transport.stop();\n    },\n\n    /**\r\n     * Get the input stream based on constraints and emit the stream event\r\n     * to the parent component so he can use it for processing or show a preview\r\n     */\n    getStream: function () {\n      var _getStream = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2() {\n        var dest;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // const stream = await navigator.mediaDevices.getUserMedia(this.constraints)\n                // this.$_stream = stream\n                // you probably DONT want to connect the microphone\n                // directly to the master output because of feedback.\n                this.$_mic = new Tone.UserMedia();\n                this.debug && console.log(\"tonejs microphone instance\", this.$_mic);\n                _context2.next = 4;\n                return this.$_mic.open();\n\n              case 4:\n                this.debug && console.log(\"mic is open\", this.$_mic);\n                dest = Tone.context.createMediaStreamDestination();\n                this.debug && console.log(\"context.createMediaStreamDestination\", dest);\n                this.$_mic.connect(dest);\n                this.debug && console.log(\"mic connected\");\n                this.$_stream = dest.stream;\n                this.$emit(\"stream\", this.$_stream);\n                return _context2.abrupt(\"return\", this.$_stream);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getStream() {\n        return _getStream.apply(this, arguments);\n      }\n\n      return getStream;\n    }(),\n\n    /**\r\n     * Create a new media recorder with the user media stream\r\n     * and set some event listeners to update component data\r\n     * and emit events to the parent component\r\n     */\n    prepareRecorder: function () {\n      var _prepareRecorder = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3() {\n        var _this = this;\n\n        var CustomMediaRecorder, workerOptions;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.$_stream) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                _context3.next = 4;\n                return loadScripts([// load OpusMediaRecorder.umd.js. OpusMediaRecorder will be loaded.\n                \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/OpusMediaRecorder.umd.js\", // load encoderWorker.umd.js. This should be after OpusMediaRecorder.\n                // This script tag will create OpusMediaRecorder.encoderWorker.\n                \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/encoderWorker.umd.js\", \"https://webrtchacks.github.io/adapter/adapter-latest.js\" // I've included NPM ones\n                // '/js/audio-service/StartAudioContext.js',\n                // '/js/audio-service/Tone.js',\n                ]);\n\n              case 4:\n                CustomMediaRecorder = window.MediaRecorder; // Check if MediaRecorder available.\n\n                if (!CustomMediaRecorder) {\n                  if (!window.OpusMediaRecorder) {\n                    console.error('OpusMediaRecorder is not defined');\n                  } // eslint-disable-next-line no-undef\n\n\n                  CustomMediaRecorder = OpusMediaRecorder;\n                } // Check if a target format (e.g. audio/ogg) is supported.\n                else if (!CustomMediaRecorder.isTypeSupported(\"audio/ogg;codecs=opus\")) {\n                    if (!window.OpusMediaRecorder) {\n                      console.error('OpusMediaRecorder is not defined');\n                    } // eslint-disable-next-line no-undef\n\n\n                    CustomMediaRecorder = OpusMediaRecorder;\n                  } // If you already load encoderWorker.js using <script> tag,\n                // you don't need to define encoderWorkerFactory.\n\n\n                workerOptions = {\n                  OggOpusEncoderWasmPath: \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/OggOpusEncoder.wasm\",\n                  WebMOpusEncoderWasmPath: \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/WebMOpusEncoder.wasm\"\n                };\n                this.$_mediaRecorder = new CustomMediaRecorder(this.$_stream, {\n                  // mimeType: this.mimeType\n                  mimeType: \"\" // browser dependent\n\n                }, workerOptions);\n                this.debug && console.log(\"⏺\", this.$_mediaRecorder);\n                this.$_mediaRecorder.ignoreMutedMedia = true;\n                this.$_mediaRecorder.addEventListener(\"start\", function () {\n                  _this.isRecording = true;\n                  _this.isPaused = false;\n\n                  _this.$emit(\"start\");\n                });\n                this.$_mediaRecorder.addEventListener(\"resume\", function () {\n                  _this.isRecording = true;\n                  _this.isPaused = false;\n\n                  _this.$emit(\"resume\");\n                });\n                this.$_mediaRecorder.addEventListener(\"pause\", function () {\n                  _this.isPaused = true;\n\n                  _this.$emit(\"pause\");\n                }); // Collect the available data into chunks\n\n                this.$_mediaRecorder.addEventListener(\"dataavailable\", function (e) {\n                  if (e.data && e.data.size > 0) {\n                    _this.chunks.push(e.data);\n                  }\n                }, true); // On recording stop get the data and emit the result\n                // than clear all the recording chunks\n\n                this.$_mediaRecorder.addEventListener(\"stop\", function () {\n                  _this.$emit(\"stop\");\n\n                  var blobData = new Blob(_this.chunks, {\n                    type: _this.$_mediaRecorder.mimeType\n                  });\n\n                  if (blobData.size > 0) {\n                    _this.$emit(\"result\", blobData);\n                  }\n\n                  _this.chunks = [];\n                  _this.isPaused = false;\n                  _this.isRecording = false;\n\n                  _this.$_mic.dispose();\n                }, true);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function prepareRecorder() {\n        return _prepareRecorder.apply(this, arguments);\n      }\n\n      return prepareRecorder;\n    }()\n  }\n};",{"version":3,"sources":["/home/amran/test-projects/vue/vue-record/src/components/SafariRecorderMixin.js"],"names":["loadScripts","StartAudioContext","Tone","methods","start","isRecording","getStream","$_stream","prepareRecorder","$_mediaRecorder","Transport","$emit","console","error","stop","getTracks","forEach","t","$_mic","close","UserMedia","debug","log","open","dest","context","createMediaStreamDestination","connect","stream","CustomMediaRecorder","window","MediaRecorder","OpusMediaRecorder","isTypeSupported","workerOptions","OggOpusEncoderWasmPath","WebMOpusEncoderWasmPath","mimeType","ignoreMutedMedia","addEventListener","isPaused","e","data","size","chunks","push","blobData","Blob","type","dispose"],"mappings":"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","sourcesContent":["import { loadScripts } from \"./loadScripts\";\r\n\r\nimport StartAudioContext from \"startaudiocontext\";\r\nimport Tone from \"tone\";\r\n\r\n// https://github.com/Tonejs/Tone.js/issues/341\r\n// https://github.com/tambien/StartAudioContext\r\n// StartAudioContext(Tone.context);\r\n\r\nexport default {\r\n  methods: {\r\n    async start() {\r\n      if (this.isRecording) {\r\n        return;\r\n      }\r\n\r\n      try {\r\n        this.$_stream = await this.getStream();\r\n        await this.prepareRecorder();\r\n\r\n        this.$_mediaRecorder.start();\r\n        Tone.Transport.start();\r\n      } catch (e) {\r\n        this.$emit(\"error\", e);\r\n        // eslint-disable-next-line\r\n        console.error(e);\r\n      }\r\n    },\r\n\r\n    stop() {\r\n      if (!this.isRecording) return;\r\n\r\n      this.$_mediaRecorder.stop();\r\n      this.$_stream.getTracks().forEach(t => t.stop());\r\n      this.$_mic.close();\r\n\r\n      Tone.Transport.stop();\r\n    },\r\n\r\n    /**\r\n     * Get the input stream based on constraints and emit the stream event\r\n     * to the parent component so he can use it for processing or show a preview\r\n     */\r\n    async getStream() {\r\n      // const stream = await navigator.mediaDevices.getUserMedia(this.constraints)\r\n      // this.$_stream = stream\r\n\r\n      // you probably DONT want to connect the microphone\r\n      // directly to the master output because of feedback.\r\n      this.$_mic = new Tone.UserMedia();\r\n      this.debug && console.log(\"tonejs microphone instance\", this.$_mic);\r\n\r\n      await this.$_mic.open();\r\n      this.debug && console.log(\"mic is open\", this.$_mic);\r\n\r\n      const dest = Tone.context.createMediaStreamDestination();\r\n      this.debug && console.log(\"context.createMediaStreamDestination\", dest);\r\n\r\n      this.$_mic.connect(dest);\r\n      this.debug && console.log(\"mic connected\");\r\n\r\n      this.$_stream = dest.stream;\r\n      this.$emit(\"stream\", this.$_stream);\r\n\r\n      return this.$_stream;\r\n    },\r\n\r\n    /**\r\n     * Create a new media recorder with the user media stream\r\n     * and set some event listeners to update component data\r\n     * and emit events to the parent component\r\n     */\r\n    async prepareRecorder() {\r\n      if (!this.$_stream) {\r\n        return;\r\n      }\r\n\r\n      /*\r\n      <!-- load OpusMediaRecorder.umd.js. OpusMediaRecorder will be loaded. -->\r\n      <script src=\"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/OpusMediaRecorder.umd.js\"></script>\r\n      <!-- load encoderWorker.umd.js. This should be after OpusMediaRecorder. -->\r\n      <!-- This script tag will create OpusMediaRecorder.encoderWorker. -->\r\n      <script src=\"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/encoderWorker.umd.js\"></script>\r\n      <script>\r\n        // Check if MediaRecorder available.\r\n        if (!window.MediaRecorder) {\r\n          window.MediaRecorder = OpusMediaRecorder;\r\n        }\r\n        // Check if a target format (e.g. audio/ogg) is supported.\r\n        else if (!window.MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {\r\n          window.MediaRecorder = OpusMediaRecorder;\r\n        }\r\n      </script>\r\n      <script type=\"text/javascript\" src=\"//webrtchacks.github.io/adapter/adapter-latest.js\"></script>\r\n      <!-- <script type=\"text/javascript\" src=\"/js/audio-service/StartAudioContext.js\"></script>\r\n      <script type=\"text/javascript\" src=\"/js/audio-service/Tone.js\"></script> -->\r\n      */\r\n\r\n      await loadScripts([\r\n        // load OpusMediaRecorder.umd.js. OpusMediaRecorder will be loaded.\r\n        \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/OpusMediaRecorder.umd.js\",\r\n        // load encoderWorker.umd.js. This should be after OpusMediaRecorder.\r\n        // This script tag will create OpusMediaRecorder.encoderWorker.\r\n        \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/encoderWorker.umd.js\",\r\n        \"https://webrtchacks.github.io/adapter/adapter-latest.js\"\r\n        // I've included NPM ones\r\n        // '/js/audio-service/StartAudioContext.js',\r\n        // '/js/audio-service/Tone.js',\r\n      ]);\r\n\r\n      let CustomMediaRecorder = window.MediaRecorder;\r\n\r\n      // Check if MediaRecorder available.\r\n      if (!CustomMediaRecorder) {\r\n        if (!window.OpusMediaRecorder) {\r\n          console.error('OpusMediaRecorder is not defined');\r\n        }\r\n\r\n        // eslint-disable-next-line no-undef\r\n        CustomMediaRecorder = OpusMediaRecorder;\r\n      }\r\n      // Check if a target format (e.g. audio/ogg) is supported.\r\n      else if (!CustomMediaRecorder.isTypeSupported(\"audio/ogg;codecs=opus\")) {\r\n        if (!window.OpusMediaRecorder) {\r\n          console.error('OpusMediaRecorder is not defined');\r\n        }\r\n\r\n        // eslint-disable-next-line no-undef\r\n        CustomMediaRecorder = OpusMediaRecorder;\r\n      }\r\n\r\n      // If you already load encoderWorker.js using <script> tag,\r\n      // you don't need to define encoderWorkerFactory.\r\n      const workerOptions = {\r\n        OggOpusEncoderWasmPath:\r\n          \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/OggOpusEncoder.wasm\",\r\n        WebMOpusEncoderWasmPath:\r\n          \"https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/WebMOpusEncoder.wasm\"\r\n      };\r\n\r\n      this.$_mediaRecorder = new CustomMediaRecorder(\r\n        this.$_stream,\r\n        {\r\n          // mimeType: this.mimeType\r\n          mimeType: \"\" // browser dependent\r\n        },\r\n        workerOptions\r\n      );\r\n      this.debug && console.log(\"⏺\", this.$_mediaRecorder);\r\n\r\n      this.$_mediaRecorder.ignoreMutedMedia = true;\r\n\r\n      this.$_mediaRecorder.addEventListener(\"start\", () => {\r\n        this.isRecording = true;\r\n        this.isPaused = false;\r\n        this.$emit(\"start\");\r\n      });\r\n\r\n      this.$_mediaRecorder.addEventListener(\"resume\", () => {\r\n        this.isRecording = true;\r\n        this.isPaused = false;\r\n        this.$emit(\"resume\");\r\n      });\r\n\r\n      this.$_mediaRecorder.addEventListener(\"pause\", () => {\r\n        this.isPaused = true;\r\n        this.$emit(\"pause\");\r\n      });\r\n\r\n      // Collect the available data into chunks\r\n      this.$_mediaRecorder.addEventListener(\r\n        \"dataavailable\",\r\n        e => {\r\n          if (e.data && e.data.size > 0) {\r\n            this.chunks.push(e.data);\r\n          }\r\n        },\r\n        true\r\n      );\r\n\r\n      // On recording stop get the data and emit the result\r\n      // than clear all the recording chunks\r\n      this.$_mediaRecorder.addEventListener(\r\n        \"stop\",\r\n        () => {\r\n          this.$emit(\"stop\");\r\n\r\n          const blobData = new Blob(this.chunks, {\r\n            type: this.$_mediaRecorder.mimeType\r\n          });\r\n          if (blobData.size > 0) {\r\n            this.$emit(\"result\", blobData);\r\n          }\r\n          this.chunks = [];\r\n          this.isPaused = false;\r\n          this.isRecording = false;\r\n\r\n          this.$_mic.dispose();\r\n        },\r\n        true\r\n      );\r\n    }\r\n  },\r\n};\r\n"]}]}